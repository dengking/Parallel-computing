# 张铁蕾 [条分缕析分布式：到底什么是一致性？](https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261779&idx=1&sn=9fb74c24f8863837d584a96536ba8189&scene=21#wechat_redirect)

> NOTE: 这篇文章对于几个"一致性"的分析是非常好的。

## ACID中的一致性

ACID是数据库事务的四个特性，分别是原子性 (Atomicity)、一致性 (Consistency)、隔离性 (Isolation)和持久性 (Durability)。

我们现在关注的是其中的C，即一致性Consistency。它是什么意思呢？通俗地说，它指的是任何一个数据库事务的执行，都应该让整个数据库保持在「一致」的状态。那怎样的状态才算「一致」呢？举个例子，假设在银行账户之间进行转账。显然，「转账」这个操作应该确保在转账前后账户总额保持不变，这是任何一个转账操作必须要遵守的规定。现在假设要从账户A向账户B转账100元，于是我们启动了一个数据库事务。在这个事务中，可以先从账号A中减去100元，再往账户B中增加100元。这样的一个事务操作，满足了“转账前后账户总额保持不变”的规定，因此我们说：这个事务操作保持了数据库的「一致性」；同时，在这个事务执行前后，数据库都处于一种「一致」的状态。



从上一段的描述中，我们容易看出：

1、ACID中的「一致性」，是对于整个数据库的「一致」状态的维持。抽象来看，对数据库每进行一次事务操作，它的状态就发生一次变化。这相当于把数据库看成了状态机，只要数据库的起始状态是「一致」的，并且每次事务操作都能保持「一致性」，那么数据库就能始终保持在「一致」的状态上 (Consistency Preservation)。

2、所谓状态是不是「一致」，其实是由业务层规定的。比如前面这个转账的例子，“转账前后账户总额保持不变”，这个规定只对于「转账」这个特定的业务场景有效。如果换一个业务场景，「一致」的概念就不是这样规定了。所以说，ACID中的「一致性」，其实是体现了业务逻辑上的合理性，并不是由数据库本身的技术特性所决定的。



经过上面的分析，现在关于ACID中的一致性，我们可以得到一些结论了：

1、ACID中的一致性，是个很偏**应用层**的概念。这跟ACID中的**原子性**、**隔离性**和**持久**性有很大的不同。原子性、隔离性和持久性，都是数据库本身所提供的技术特性；而一致性，则是由特定的业务场景规定的。怪不得《Designing Data-Intensive Applications》[1]一书的作者在书中写道："The letter C doesn’t really belong in ACID"。

2、要真正做到ACID中的一致性，它是要依赖数据库的原子性和隔离性的（应对错误和并发）。但是，就算数据库提供了所有你所需要的技术特性，也不一定能保证ACID的一致性。这还取决于你在应用层对于事务本身的实现逻辑是否正确无误。

3、最后，ACID中的一致性，甚至跟分布式都没什么直接关系。它跟分布式的唯一关联在于，在分布式环境下，它所依赖的数据库原子性和隔离性更难实现。

总之，ACID中的一致性，是一个非常特殊的概念。除了数据库事务处理，它很难扩展到其它场景，也跟分布式理论中的其它「一致性」概念没有什么关系。



## 分布式事务与共识算法的关系

先说共识问题 (consensus problem)。这是分布式系统中的一个十分基础而核心的问题，它表示如何在分布式系统中的多个节点之间就某事达成共识。

网上通常提到的「分布式一致性协议」，或者「分布式一致性算法」，一般来说就是解决这里的共识问题的算法。用词的不同，是由于中英文翻译造成的。这些算法或协议，经常包含Paxos之类，但也可能包括两阶段提交协议(2PC)或三阶段提交协议(3PC)。

人们既然经常将Paxos、2PC、3PC这些算法放在一起讨论，那么它们之间势必存在着某种相似性的。但这种相似性是怎么来的呢？我们仔细分析一下:

1、Paxos，是解决共识问题的通用算法。它允许每个节点提出自己的提议(称为proposal），而Paxos算法能够不借助于任何中心化节点，保证各个节点之间对于提议最终达成一致。这里的proposal，是一个抽象的概念，它可以包含任何你想达成共识的数值。

2、2PC和3PC，则是为了解决分布式事务提交问题的。



这样从表面看起来，Paxos和2PC、3PC，这两类算法似乎没有多少相似性。2PC和3PC是跟分布式事务强相关的，而Paxos跟分布式事务没有什么特别的关系。为了分析更深层次的本质，我们探究一下2PC和3PC产生的背景。

### ACID中的原子性 (Atomicity)

回到事务的概念。事务本来和分布式没什么直接关系的，就算在一个单节点的数据库上，要实现出事务的ACID特性，也不是那么容易的。只是，如同在前一章节的结尾我们提到的，在分布式环境下，事务的ACID特性更难实现。在前一章中我们主要关注ACID中的**一致性**，现在我们关注一下**ACID中的原子性 (Atomicity)**。



ACID中的**原子性**，要求事务的执行要么全部成功，要么全部失败，而不允许出现“部分成功”的情况。在分布式事务中，这要求参与事务的所有节点，要么**全部执行Commit操作**，要么**全部执行Abort操作**。换句话说，参与事务的所有节点，需要在“执行Commit还是Abort”这一点上达成一致（其实就是**共识**）。这个问题在学术界被称为**原子提交问题**（**Atomic Commitment Problem**）[2]，而能够解决原子提交问题的算法，则被称为原子提交协议（**Atomic Commitment Protocal**，简称**ACP**）[3]。2PC和3PC，属于**原子提交协议**两种不同的具体实现。

分析到这里，我们似乎发现了**原子提交问题**与**共识问题**的**关联性**：

1、**共识问题**，解决的是如何在分布式系统中的多个节点之间就某个提议达成**共识**。

2、**原子提交问题**，解决的是参与分布式事务的所有节点在“执行Commit还是Abort”这一点上达成**共识**。

3、所以，**原子提交问题**是**共识问题**的一个特例。

这个酷似「三段论」式的论述，看起来“合情合理”。实际上，学术界在很长一段时间内都认为，**分布式事务**的**原子提交问题**是**拜占庭将军问题**（**Byzantine Generals Problem**）的一个退化形式[4]。什么是**拜占庭将军问题**呢？简单来说，它也是**分布式系统**的一种**共识问题**，而且是**容错性**要求最高的一种共识问题。我们在这里不展开讨论拜占庭将军问题了，如果你对细节感兴趣，欢迎阅读我之前的另一篇文章“[漫谈分布式系统、拜占庭将军问题与区块链](https://mp.weixin.qq.com/s?__biz=MzA4NTg1MjM0Mg==&mid=2657261626&idx=1&sn=6b32cc7a7a62bee303a8d1c4952d9031&scene=21#wechat_redirect)”。总之，学术界以前的这种观点，跟我们刚刚分析得到的结论（原子提交问题是共识问题的一个特例）差不多。

### 共识 VS 原子提交问题

但是，**分布式系统**的诡异之处就要体现在这里，一些细节的不同，可能导致非常大的差异。如果你仔细看前文的描述，会发现这样一个细节：当我们描述**共识问题**的时候，我们说的是在**多个节点**之间达成共识；而当我们描述**原子提交问题**的时候，我们说的是在**所有节点**之间达成共识。这个细微的差别，让这两类问题，几乎变成了完全不同的问题（谁也替代不了谁）。



故障的节点可能什么都做不了，如何参与达成**共识**呢？这里的意思是，等故障节点恢复之后，它的决策（Commit或是Abort）必须与其它所有节点保持一致。那么，这是不是意味着，只要有节点发生故障，**原子提交协议**就一定会**阻塞**呢？这里有点让人奇怪，答案是「不一定」。根源就在于Abort和Commit并不是对等的决策。假设有一个节点宕机了，其它节点大可以选择Abort决策（注意不能选择Commit），从而让整个事务Abort掉（没有被**阻塞**住，等待宕机的节点恢复）。等宕机的那个节点恢复了，它会发现相应的事务已经执行Abort了，那么它也按照Abort处理就好了。在这个过程中，参与分布式事务的**所有节点**（包括宕机的这个节点）对于“执行Commit还是Abort”也是达成了共识的（这个共识是Abort）。正是这些细微却至关重要的细节，让**2PC**和**3PC**这种看似简单的协议实现起来没有那么容易。

### uniform consensus VS consensus problem

论文[5]进一步澄清了这一问题，**原子提交问题**被抽象成一个新的一致性问题，称为**uniform consensus**问题，它是与通常的共识问题（**consensus problem**）不同的问题，而且是更难的问题。uniform consensus，要求所有节点（包括故障节点）都要达成共识；而consensus问题只关注没有发生故障的节点达成共识。

### 结论

至此，我们总结一下本章节的结论：

1、共识问题（consensus problem），解决的是如何在分布式系统中的多个节点之间就某个提议达成共识。它只关注没有发生故障的节点达成共识就可以了。

2、在分布式事务中，ACID中的原子性，引出了**原子提交问题**，它解决的是参与分布式事务的所有节点在“执行Commit还是Abort”这一点上达成共识。**原子提交问题**属于**uniform consensus问题**，要求所有节点（包括**故障节点**）都要达成共识，是比consensus问题更难的一类问题。

3、Paxos和解决拜占庭将军问题的算法，解决的是consensus问题；2PC/3PC，解决的是一个特定的uniform consensus问题。



## CAP与线性一致性

CAP的三个字母分别代表了分布式系统的三个特性：**一致性（Consistency）**、**可用性（Availability）**和**分区容错性（Partition-tolerance）**。而CAP定理指出：任何一个分布式系统只能同时满足三个特性中的两个。但是，这一描述曾经引发了非常多的误解。

### **linearizability**

为了进一步展开讨论，我们先关注CAP中的C，也就是一致性。它是什么意思呢？在证明CAP定理的原始论文中[6]，**C**指的是**linearizable consistency**，也就是「线性一致性」。更精简的英文表达则是**linearizability**。

这听起来可能稍微有点奇怪，但事实就是这样。线性一致性（linearizability）是CAP中的C的原始定义。而很多人在谈到CAP时，则会把这个C看成是强一致性（strong consistency）。这其实也没错，因为线性一致性的另一个名字，就是强一致性[1]。只不过，相比「线性一致性」来说，「强一致性」并不是一个好名字。因为，从这个名字你看不出来它真实的含义（到底「强」在哪？）。在下面的讨论中，我们统一使用线性一致性(linearizability)这个词汇。

那**线性一致性**是什么意思呢？它精确的形式化定义[7]非常抽象，且难以理解。大体上是说，在一个并发执行的环境中，不同的操作之间可能是有严格的先后关系的（一个操作执行结束之后另一个操作才开始执行），也可能是并发执行的（一个操作还没执行结束，另一个操作就开始执行了）；如果能够把所有操作排列成一个「合法」的全局线性顺序，那么这些操作就是满足线性一致性的。当然，在这个重新排列的过程中，原来就存在的严格的先后关系，必须得以保持。

但是，怎么才算合法呢？我们具体到一个存储系统中通过例子来说明。假如我们先往某个数据对象中写入了一个值（假设是1），然后在写入操作结束之后，我们再把这个数据对象读出来（在写入和读取操作之间没有其它的写入操作了）。如果我们发现读取到的值是1，那么就是合法的；而如果读出来的值不是1，那么就是非法的。再假设，我们又执行了一次读取操作，发现读出来的值仍然是1，那么就是合法的；否则就是非法的。也就是说，如果一个读操作已经读到了某个值，那么下一个对于同一个数据对象的读操作就必须读取到同样的值（除非在两次读操作之间还存在别的写入操作）。



这些例子都比较容易理解，因为站在观察者的角度它们是符合逻辑的。因此，对于一个分布式存储系统来说，线性一致性的含义可以用一个具体的描述来取代：对于任何一个数据对象来说，系统表现得就像它只有一个副本一样[1]。“表现得像只有一个副本”，也就相当于满足了前面的「合法」条件。显然，如果系统对于每个数据对象真的只存一个副本，那么肯定是满足线性一致性的。但是单一副本不具有容错性，所以分布式存储系统一般都会对数据进行复制（replication），也就是保存多个副本。这时，在一个分布式多副本的存储系统中，要提供线性一致性的保证，就需要付出额外的成本了。

网上对于CAP的一致性的通俗解释，通常有两种：

1、一致性是指：在分布式系统完成某写操作后的任何读操作，都应该获取到该写操作写入的那个最新的值。显然，如果系统“表现得像只有一个副本”一样，这个描述是成立的。不过这只是描述了线性一致性的一个特例而已，有以偏概全的嫌疑。

2、一致性是指：保持所有节点在同一个时刻具有相同的、逻辑一致的数据。显然这种解释并不是从观察者的角度来描述的，而是试图从系统内部的行为（内部实现）来描述的。「所有节点」，可能指的是「所有副本」；至于“在同一个时刻具有相同的、逻辑一致的数据”这个说法，则似乎离线性一致性的本来含义偏离太远了。从逻辑上说，“表现得像只有一个副本”，并不一定需要系统“在同一个时刻具有相同的、逻辑一致的数据”。线性一致性可能有很多种实现方式，而这种解释规定了一种具体的系统实现，同样有以偏概全的嫌疑。

我们前面提到，线性一致性，也被称为强一致性。之所以这么说，大概是因为线性一致性要求多个副本上的数据必须保持如此之「强」的一致性，以至于“让系统表现得就像只有一个副本”。

### 总结

在历史上，CAP定理具有巨大的知名度，但它实际的影响力却没有想象的那么大。随着分布式理论的发展，我们逐渐认识到，CAP并不是一个「大一统」的理论，远不能涵盖分布式系统设计中方方面面的问题。相反，CAP引发了很多误解和理解上的混乱（细节不讨论了）。因此，可以预见到，未来CAP定理的影响将会进一步被削弱。



## 小结

本文我们辨析了分布式系统中的诸多被称为「一致性」的概念。但这个话题还没有完，我将在下一篇文章中跟大家继续讨论顺序一致性、线性一致性、最终一致性等概念。