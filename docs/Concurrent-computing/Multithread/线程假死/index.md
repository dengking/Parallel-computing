# 线程假死

## [分析一个常见的java多线程通信问题（假死现象）](http://baijiahao.baidu.com/s?id=1645903264094783673&wfr=spider&for=pc)

> NOTE: 这篇文章分析的较好

### 二、假死状态分析

其实出现这个现象的原因很简单，那就是和我们的wait/notify机制有关，我们几句话来总结一下：

“假死”的现象就是全部线程都进入了WAITING状态（死锁），则程序就不再执行任何业务功能了，整个项目呈停止状态。上面的案例中出现假死的现象是由于仅仅唤醒了同类（生产者唤醒了生产者，消费者唤醒了消费者）的现象大量出现导致的。

> NOTE: 其实就是**死锁**

下面我们画一张图来分析一下：

![img](http://pics7.baidu.com/feed/f636afc379310a558d821c8bf4dcc1ac8326104d.jpeg?token=c1bb7157ad4248c66cc8e420c78fa2e2&s=60956F32D18F40EA02D9FDDA00005031)

也就是说notify通知的是是同类。造成了这种堵塞现象。这是其根本原因，而且这张图是我们自己画的。下面我们就直接使用jstack工具来分析一下线程的状态。这两个工具是jdk自带的，我们可以直接使用。



现在我们知道了，目前所有的线程都是处于等待的状态，这也就是假死现象的验证。

假死现象的原因我们知道了，那么我们如何改正呢？

### 三、假死状态修复

假死现象的改正其实很简单，网上的方式也很多，比如说通过BlockingQueue或者是notifyAll方法。notifyAll方法超级简单，就是把上面produce和consume方法中的notify改成notifyAll方法即可。目的就是通知到所有的其他线程，生产线程该生产的生产，消费线程该消费的消费。

对于java多线程的系列的文章，这算是基础入门。还有更多文章我也经持续发布。感谢支持。OK，今天的文章先到这。

## [高并发编程：9、wait、notify、notifyAll（二 程序假死的原因分析）](https://blog.csdn.net/oJueQiang123456/article/details/97311168)

> NOTE: 生产者线程和消费者线程同时进入等待状态

> 